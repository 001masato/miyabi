# Command Stack - コマンドスタック手法

**Version**: 1.0.0
**Last Updated**: 2025-11-07
**Concept**: 階層的タスク分解と連鎖実行

---

## 🎯 概要

**Command Stack（コマンドスタック）**は、複雑なタスクを構造化された見出しとユーザープロンプトのペアに分解し、連鎖的に実行することで最終成果物を生成する手法。

### 核心原則

```
複雑なタスク → [C1] 構造化 → [C2] プロンプト化 → [C3] 連鎖実行 → 最終成果物
```

---

## 📋 基本構文

### テンプレート

```
＝＝＝
ゴールは：{{最終的に達成したい目標}}
成果物は：{{生成すべき具体的なアウトプット}}
参考例は：{{参考にすべき例やフォーマット}}
＝＝＝

[C1]: 見出しを構造化して整理します
      インデックスとして行動化してインデント構造で構造化し
      見出しの内容を上位構造、中位構造、下位構造で構造化します

[C2]: 見出しに対して、各見出しに対してのインストラクションとして
      ユーザープロンプトを作ってください。
      必ずUserの求める成果物を生成するための指示です。
      キーのペアの要素として見出しの構造と見出しに対する
      差し込みのユーザーインプットとしてのユーザープロンプトを作ります。

[C3]: 各見出しとユーザープロンプトのペアを実行していきます
      それぞれインデックスとして1番からN番まで番号を振って
      コマンドラン1からnとして連続でループします
      1からnとして連続でループして最終成果物を書き出す

'''
[成果物 XXを書く]

C1 C2 C3 All Run
'''

Task1[]
Task2[]
Task3[]
```

---

## 🔄 3ステップワークフロー

### [C1] 構造化フェーズ

**目的**: タスクを階層構造に分解

**プロセス**:
1. 最終成果物から逆算して必要な見出しを抽出
2. 上位構造（章レベル）、中位構造（節レベル）、下位構造（項目レベル）に階層化
3. インデント構造で視覚的に整理
4. 各見出しにインデックス番号を付与

### [C2] プロンプト化フェーズ

**目的**: 各見出しに対応する実行可能なユーザープロンプトを作成

**プロセス**:
1. C1で作成した各見出しに対して、具体的な指示文を作成
2. 見出し（Key）とプロンプト（Value）のペアを形成
3. プロンプトは成果物生成のための明確な指示を含む
4. 前のステップの出力を次のステップの入力として利用可能にする

### [C3] 連鎖実行フェーズ

**目的**: プロンプトを順次実行し、最終成果物を生成

**プロセス**:
1. インデックス1からN番まで順番にプロンプトを実行
2. 各ステップの出力を次のステップのコンテキストとして渡す
3. 累積的に成果物を構築
4. 全ステップ完了後、統合された最終成果物を出力

---

## 🧩 World Model Logicとの統合

Command Stackは、World Model Logicにおける**θ₂ Generate（計画生成）**フェーズの具体的実装手法。

### 関係性

```
θ₁ Understand: タスクを理解
   ↓
θ₂ Generate: Command Stack適用
   ├─ [C1] 構造化 → タスク分解
   ├─ [C2] プロンプト化 → 実行計画
   └─ [C3] 連鎖実行 → 実行シーケンス生成
   ↓
θ₃ Allocate: リソース割り当て
   ↓
θ₄ Execute: 各コマンド実行（World₀ → World₁ → ... → World_N）
   ↓
θ₅ Integrate: 結果統合
   ↓
θ₆ Learn: 学習・最適化
```
